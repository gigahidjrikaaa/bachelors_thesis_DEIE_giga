\chapter*{APPENDIX}
\label{appendix:tool-registry}

\section{Tool Registry \& Interfaces}

This appendix lists the tool definitions that enable the Meta-Agent (Aika) to interact with the specialist agents and external services. These tools are exposed to the LLM via function calling.

\subsection{Tool Registry System}
The system uses a decorator-based registry to manage tool definitions and ensure type safety.

\begin{lstlisting}[language=Python, caption={Tool Registry Decorator (registry.py)}]
"""
Tool Registry System with Decorator Pattern

This module provides a centralized registry for all Aika tools, eliminating redundancy
and providing a single source of truth for tool definitions.

Architecture:
- Tools are registered using @register_tool decorator
- Schema definitions are co-located with implementations
- Auto-generates Gemini function calling schemas
- Auto-routes tool execution in orchestrator
"""

def register_tool(
    name: str,
    description: str,
    parameters: Dict[str, Any],
    category: str = "general",
    requires_db: bool = True,
    requires_user_id: bool = True,
):
    """
    Decorator to register a tool with the Aika tool system.
    
    Args:
        name: Tool name (must be unique)
        description: Detailed description for Gemini to understand when to use
        parameters: JSON Schema for tool parameters
        category: Tool category (agent, scheduling, user, analytics, etc.)
        requires_db: Whether tool needs database session
        requires_user_id: Whether tool needs user_id
    """
    def decorator(func: Callable) -> Callable:
        # Validate tool name is unique
        if name in _TOOL_REGISTRY:
            logger.warning(f"Tool '{name}' is already registered. Overwriting...")
        
        # Register tool
        _TOOL_REGISTRY[name] = {
            "name": name,
            "description": description,
            "parameters": parameters,
            "category": category,
            "requires_db": requires_db,
            "requires_user_id": requires_user_id,
            "handler": func,
        }
        
        logger.debug(f"Registered tool: {name} (category: {category})")
        return func
    return decorator
\end{lstlisting}

\subsection{Meta-Agent Tool Definitions}
The Meta-Agent uses these tools to delegate tasks to specialist agents.

\begin{lstlisting}[language=Python, caption={Aika Tool Wrapper (tools.py)}]
"""Tool definitions and handlers for Aika's function calling capabilities.

REFACTORED: This module now uses the NEW decorator-based registry system.

Changes (Latest):
- Updated to use @register_tool decorator pattern
- All tools registered via registry.py
- Zero redundancy architecture
- Auto-generated Gemini schemas
"""

def get_aika_tools() -> List[Dict[str, Any]]:
    """Return list of tools available to Aika.
    
    This function is used by legacy code that expects a list of tool schemas.
    For new code, use generate_gemini_tools() directly from the registry.
    
    Returns:
        List[Dict]: Tool schemas for Gemini function calling
    """
    try:
        # Use NEW registry to get all tools
        # The registry contains:
        # - agent tools (STA, TCA, CMA, IA, general_query)
        # - scheduling tools (book_appointment, get_available_counselors, etc.)
        all_tools_dict = get_all_tools()  # Returns Dict[str, Dict]
        all_tools = list(all_tools_dict.values())  # Convert to List[Dict]
        
        logger.info(f"Loaded {len(all_tools)} tools for Aika from registry")
        
        # Return list of tool configurations
        return all_tools
        
    except Exception as e:
        logger.error(f"Error loading Aika tools: {e}")
        return []
\end{lstlisting}
