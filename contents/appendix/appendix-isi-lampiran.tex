\chapter*{APPENDIX}
\label{appendix:agent-orchestration}

\section{Agent Orchestration \& State Machines}

This appendix provides the core LangGraph definitions that orchestrate the behavior of the specialist agents. These state machines define the flow of data, validation steps, and decision logic for each agent.

\subsection{Safety Triage Agent (STA) Graph}
The Safety Triage Agent (STA) is responsible for detecting crisis signals and routing them appropriately.

\begin{lstlisting}[language=Python, caption={STA LangGraph Definition (sta\_graph.py)}]
"""LangGraph state machine for Safety Triage Agent (STA).

This module implements the STA workflow as a LangGraph StateGraph:
    ingest_message -> apply_redaction -> assess_risk -> decide_routing

The graph integrates with existing SafetyTriageService for classification
and ExecutionStateTracker for real-time monitoring.
"""
from __future__ import annotations

import logging
from typing import Callable
from datetime import datetime

from langgraph.graph import StateGraph, END
from sqlalchemy.ext.asyncio import AsyncSession

from app.agents.graph_state import STAState
from app.agents.sta.service import get_safety_triage_service
from app.agents.sta.schemas import STAClassifyRequest
from app.agents.execution_tracker import execution_tracker
from app.core.redaction import redact_pii_regex

logger = logging.getLogger(__name__)


async def ingest_message_node(state: STAState) -> STAState:
    """Node: Ingest and validate user message."""
    execution_id = state.get("execution_id")
    if execution_id:
        execution_tracker.start_node(execution_id, "sta:ingest_message", "sta")
    
    # Validate required fields
    if not state.get("message"):
        state["errors"].append("No message provided")
        if execution_id:
            execution_tracker.fail_node(execution_id, "sta:ingest_message", "No message")
        return state
    
    state["execution_path"].append("ingest_message")
    
    if execution_id:
        execution_tracker.complete_node(execution_id, "sta:ingest_message")
    
    logger.info(f"STA ingested message for user {state.get('user_hash', 'unknown')}")
    return state


async def apply_redaction_node(state: STAState, db: AsyncSession) -> STAState:
    """Node: Apply PII redaction to message."""
    execution_id = state.get("execution_id")
    if execution_id:
        execution_tracker.start_node(execution_id, "sta:apply_redaction", "sta")
    
    try:
        original_message = state["message"]
        
        # Use existing redaction service (returns tuple of redacted_text, counts)
        redacted_message, redaction_counts = redact_pii_regex(original_message)
        state["redacted_message"] = redacted_message
        state["execution_path"].append("apply_redaction")
        
        if execution_id:
            execution_tracker.complete_node(execution_id, "sta:apply_redaction")
        
        logger.info(f"STA redacted PII from message (original length: {len(original_message)}, redactions: {sum(redaction_counts.values())})")
        
    except Exception as e:
        error_msg = f"Redaction failed: {str(e)}"
        state["errors"].append(error_msg)
        logger.error(error_msg, exc_info=True)
        
        if execution_id:
            execution_tracker.fail_node(execution_id, "sta:apply_redaction", str(e))
    
    return state
\end{lstlisting}

\subsection{Therapeutic Coach Agent (TCA) Graph}
The Therapeutic Coach Agent (TCA) generates personalized intervention plans based on the user's intent and severity.

\begin{lstlisting}[language=Python, caption={TCA LangGraph Definition (tca\_graph.py)}]
"""LangGraph state machine for Therapeutic Coach Agent (TCA).

This module implements the TCA workflow as a LangGraph StateGraph:
    ingest_triage_signal -> determine_intervention_type -> generate_plan -> 
    safety_review -> persist_plan

The graph integrates with TherapeuticCoachService and uses Gemini AI for 
personalized intervention plan generation.
"""
from __future__ import annotations

import logging
from datetime import datetime

from langgraph.graph import StateGraph, END
from sqlalchemy.ext.asyncio import AsyncSession

from app.agents.graph_state import SCAState
from app.agents.tca.service import TherapeuticCoachService
from app.agents.tca.schemas import SCAInterveneRequest
from app.agents.execution_tracker import execution_tracker
from app.domains.mental_health.models import InterventionPlanRecord

logger = logging.getLogger(__name__)


async def ingest_triage_signal_node(state: SCAState) -> SCAState:
    """Node: Ingest triage signal from STA."""
    execution_id = state.get("execution_id")
    if execution_id:
        execution_tracker.start_node(execution_id, "tca::ingest_triage_signal", "tca")
    
    # Validate STA outputs are present
    if not state.get("severity") or not state.get("intent"):
        state["errors"].append("Missing STA risk assessment data")
        if execution_id:
            execution_tracker.fail_node(
                execution_id, 
                "tca::ingest_triage_signal", 
                "Missing STA data"
            )
        return state
    
    state["execution_path"].append("ingest_triage_signal")
    
    if execution_id:
        execution_tracker.complete_node(execution_id, "tca::ingest_triage_signal")
    
    logger.info(
        f"TCA ingested triage signal: severity={state.get('severity')}, "
        f"intent={state.get('intent')}"
    )
    return state


async def determine_intervention_type_node(state: SCAState) -> SCAState:
    """Node: Determine appropriate intervention type."""
    execution_id = state.get("execution_id")
    if execution_id:
        execution_tracker.start_node(execution_id, "tca::determine_intervention_type", "tca")
    
    try:
        intent = state.get("intent", "").lower()
        severity = state.get("severity", "low").lower()
        
        # Map intent to intervention type
        if intent in ("crisis", "panic", "anxiety", "acute_stress"):
            intervention_type = "calm_down"
        elif intent in ("overwhelmed", "stuck", "confused", "academic_stress"):
            intervention_type = "break_down_problem"
        else:
            intervention_type = "general_coping"
        
        state["intervention_type"] = intervention_type
        state["should_intervene"] = True
        state["execution_path"].append("determine_intervention_type")
        
        if execution_id:
            execution_tracker.complete_node(execution_id, "tca::determine_intervention_type")
            
    except Exception as e:
        # Error handling omitted for brevity
        pass
        
    return state
\end{lstlisting}

\subsection{Case Management Agent (CMA) Graph}
The Case Management Agent (CMA) handles high-severity cases that require human escalation.

\begin{lstlisting}[language=Python, caption={CMA LangGraph Definition (cma\_graph.py)}]
async def ingest_escalation_node(state: SDAState) -> SDAState:
    """Node: Ingest escalation signal from STA."""
    execution_id = state.get("execution_id")
    if execution_id:
        execution_tracker.start_node(execution_id, "cma::ingest_escalation", "cma")
    
    # Validate this should be escalated
    severity = state.get("severity", "low")
    if severity not in ("high", "critical"):
        errors = state.get("errors", [])
        errors.append(
            f"CMA should only handle high/critical cases, got severity={severity}"
        )
        state["errors"] = errors
        if execution_id:
            execution_tracker.fail_node(
                execution_id, 
                "cma::ingest_escalation", 
                f"Invalid severity: {severity}"
            )
        return state
    
    execution_path = state.get("execution_path", [])
    execution_path.append("ingest_escalation")
    state["execution_path"] = execution_path
    
    if execution_id:
        execution_tracker.complete_node(execution_id, "cma::ingest_escalation")
    
    logger.info(
        f"CMA ingested escalation: severity={severity}, "
        f"user_hash={state.get('user_hash')}"
    )
    return state
\end{lstlisting}

\subsection{Insights Agent (IA) Graph}
The Insights Agent (IA) performs privacy-preserving analytics on the system data.

\begin{lstlisting}[language=Python, caption={IA LangGraph Definition (ia\_graph.py)}]
"""LangGraph state machine for Insights Agent (IA).

This module implements the IA workflow as a LangGraph StateGraph:
    Phase 1 (Data Collection):
        ingest_query -> validate_consent -> apply_k_anonymity -> execute_analytics
    Phase 2 (Intelligence Layer):
        interpret_results -> generate_narrative -> create_recommendations -> export_pdf
"""

def ingest_query_node(state: IAState) -> IAState:
    """Node: Validate and ingest analytics query request."""
    execution_id = state.get("execution_id")
    if execution_id:
        execution_tracker.start_node(execution_id, "ia:ingest_query", "ia")
    
    try:
        # Validate required fields
        if not state.get("question_id"):
            raise ValueError("question_id is required")
        
        if not state.get("start_date") or not state.get("end_date"):
            raise ValueError("start_date and end_date are required")
        
        # Validate date range (prevent excessive historical queries)
        start = state.get("start_date")
        end = state.get("end_date")
        
        if not start or not end:
            raise ValueError("start_date and end_date must be provided")
        
        if start >= end:
            raise ValueError("start_date must be before end_date")
        
        max_days = 365  # Maximum 1 year of data
        delta = end - start
        if delta.days > max_days:
            raise ValueError(f"Date range too large. Maximum {max_days} days allowed.")
        
        state.setdefault("execution_path", []).append("ia:ingest_query")
        state["query_validated"] = True
        
        if execution_id:
            execution_tracker.complete_node(execution_id, "ia:ingest_query")
        
        logger.info(f"IA ingested query: question_id={state.get('question_id')}, range={delta.days} days")
        
    except Exception as e:
        error_msg = f"Query ingestion failed: {str(e)}"
        logger.error(error_msg)
        state.setdefault("errors", []).append(error_msg)
        
        if execution_id:
            execution_tracker.fail_node(execution_id, "ia:ingest_query", error_msg)
    
    return state
\end{lstlisting}
